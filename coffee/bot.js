// Generated by CoffeeScript 1.4.0
var Bot;

Bot = (function() {

  function Bot(side) {
    console.log("created a new bot!");
    this.name = "Gandalf";
    this.infinity = 99;
    this.side = side;
  }

  Bot.prototype.calculateMove = function(board) {
    var boardCopy, copiedSpaces, isBoardEmpty, move;
    console.log("Bot.calculateMove with " + board);
    isBoardEmpty = function(board) {
      var boardSpaces, space, _i, _len;
      console.log("Bot.calculateMove: board is " + board);
      boardSpaces = board.getSpaces();
      for (_i = 0, _len = boardSpaces.length; _i < _len; _i++) {
        space = boardSpaces[_i];
        console.log("Bot.calculateMove: checking if space " + space + " is empty");
        if (typeof space === "string") {
          console.log("Bot.calculateMove: board isn't empty");
          return false;
        }
      }
      return true;
    };
    if (isBoardEmpty(board)) {
      return 4;
    }
    boardCopy = jQuery.extend(true, {}, board);
    copiedSpaces = boardCopy.getSpaces();
    console.log("copiedSpaces are: " + copiedSpaces);
    console.log("about to call Bot.move");
    move = this.search(boardCopy, this.side, 0, -this.infinity, +this.infinity);
    return move;
  };

  Bot.prototype.search = function(board, side, depth, alpha, beta) {
    var bestMove, move, moves, otherside, potentialAlpha, value, _i, _len;
    alert("in Bot.search");
    console.log("Bot.search: board is " + board);
    console.log("Bot.search: side is " + side);
    console.log("Bot.search: depth is " + depth);
    value = this.nodeValue(board, side);
    console.log("Bot.search: depth is " + depth);
    console.log("Bot.search: value is " + value);
    if (value !== 0) {
      if (value > 0) {
        return value - depth;
      } else {
        return value + depth;
      }
    }
    moves = this.generateMoves(board);
    if (moves.length === 0) {
      return value;
    }
    otherside = side === 'X' ? 'O' : 'X';
    console.log("Bot.search: otherside is " + otherside);
    for (_i = 0, _len = moves.length; _i < _len; _i++) {
      move = moves[_i];
      console.log("Bot.search: " + move + " in moves");
      this.makeMove(board, move, side);
      potentialAlpha = -this.search(board, otherside, depth + 1, -beta, -alpha);
      console.log("Bot.search: potentialAlpha");
      this.undoMove(board, move);
      console.log("Bot.search: undoMove");
      if (beta <= alpha) {
        break;
      }
      if (potentialAlpha > alpha) {
        alpha = potentialAlpha;
        if (depth === 0) {
          bestMove = move;
        }
      }
    }
    debugger;
    if (depth !== 0) {
      return alpha;
    } else {
      return bestMove;
    }
  };

  Bot.prototype.nodeValue = function(board, side) {
    var gameResult;
    console.log("Bot.nodeValue: board is " + board + " and side is " + side);
    gameResult = checkGameOver(board);
    console.log("Bot.nodeValue: gameResult is " + gameResult);
    if (gameResult === false || 'tie') {
      return 0;
    } else if (gameResult === side) {
      return this.infinity;
    } else {
      return -this.infinity;
    }
  };

  Bot.prototype.generateMoves = function(board) {
    var boardSpaces, moves, space, _i, _len;
    console.log("Bot.generateMoves: board is " + board);
    moves = [];
    boardSpaces = board.getSpaces();
    console.log("Bot.generateMoves: got boardSpaces");
    for (_i = 0, _len = boardSpaces.length; _i < _len; _i++) {
      space = boardSpaces[_i];
      if (typeof space === "number") {
        moves.push(space);
      }
    }
    console.log("Bot.generateMoves: moves are " + moves);
    return moves;
  };

  Bot.prototype.makeMove = function(board, move, side) {
    return board[move] = side;
  };

  Bot.prototype.undoMove = function(grid, move) {
    return board[move] = move;
  };

  return Bot;

})();
